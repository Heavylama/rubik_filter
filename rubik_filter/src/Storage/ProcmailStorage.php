<?php


namespace Rubik\Storage;

use phpseclib\Net\SFTP;

class ProcmailStorage
{

    public const PROCMAIL_FILE = ".procmailrc";
    public const PROCMAIL_BACKUP_FILE = ".bak.procmailrc";
    public const RUBIK_SECTION_HEADER
        = "########################################################################################\n".
          "# AUTOMAGICALLY GENERATED BY ROUNDCUBE RUBIK FILTER PLUGIN, DO NOT CHANGE THIS SECTION #\n".
          "# HASH: %s                                               #\n".
          "########################################################################################\n";
    public const RUBIK_SECTION_FOOTER
        = "########################################################################################\n".
          "# END OF AUTOMAGICALLY GENERATED SECTION                                               #\n".
          "########################################################################################\n";

    /**
     * @var SFTP
     */
    private $sftp;
    private $user;
    private $password;

    public function __construct($host, $login, $pw)
    {
        $this->sftp = new SFTP($host);
        $this->user = $login;
        $this->password = $pw;
    }

    public function __destruct()
    {
        $this->sftp->disconnect();
    }

    public function getProcmailRules() {
        if (!($procmail = $this->getProcmailFile())) {
            return null;
        }

        // check if rubik filter section already exists or not
        return $this->getRubikSection($procmail);
    }

    private function createHash($rules) {

    }

    private function getRubikSection($procmailrc) {

    }

    private function backupProcmail($content) {
        return $this->sftp->put(self::PROCMAIL_BACKUP_FILE, $content);
    }

    private function getProcmailFile() {
        return $this->sftp->get(self::PROCMAIL_FILE);
    }

    private function ensureConnection() {
        return $this->sftp->isConnected() || $this->sftp->login($this->user, $this->password);
    }
}